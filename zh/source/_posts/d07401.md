---
title: 在 Arch Linux 上用 cgproxy Qv2ray 和 Trojan-go 实现全局代理
date: 2021-10-19 15:52:53
updated: 2022-10-07 16:16:15
categories:
tags:
- Linux
- Proxy
- iptables
- Qv2ray
- cgproxy
- v2ray
description:
  赶紧把 mellow-io/mellow 换下来，这玩意好几次炸了我的网卡。
---

{% btn '/en/src/d07401',View in English,,blue larger %}

---

{% note warning %}

自 2022-10-05 起，`libbpf` 版本从 `0.8.1` 升级到 `1.0.1` 后，`libbpf.so.0.8.1` 不复存在，`cgproxy` 因此失去重要依赖 `libbpf.so.0` , 无法正常启动。

[上游](https://github.com/springzfx/cgproxy) 自 2020 年 8 月起已经不再更新，在其他开发者接手之前，手动添加驱动以维持运行，**仅作权宜之计**。

故从 2022-10-04 的 Arch Linux Archive 获取

[libbpf 0.8.1 package](https://archive.archlinux.org/repos/2022/10/04/core/os/x86_64/libbpf-0.8.1-1-x86_64.pkg.tar.zst)

[libbpf 0.8.1 package signature](https://archive.archlinux.org/repos/2022/10/04/core/os/x86_64/libbpf-0.8.1-1-x86_64.pkg.tar.zst.sig)

验证后，解压，将其中的 `libbpf.so.0.8.1` 移到 `/usr/lib/` 下，添加软连接

```bash
sudo ln -s /usr/lib/libbpf.so.0.8.1 /usr/lib/libbpf.so.0
```

应该足以使 `cgproxy` 继续运行一段时间。

但出于安全考虑，仍建议尽快转移到其他透明代理工具，例如 `v2rayA` .

{% endnote %}





## `Mellow` 麻烦多多

我想试试滥用 `iptables`. 

`mellow` 是通过虚拟网卡实现全局代理的，不过我切换配置的时候，它可能会突然崩溃，然后让网卡全部下线。我用了好几天，读了多少日志，发了多少火，直到找到这篇文章，才解决这个倒霉问题。

链接在这里。

https://archived.forum.manjaro.org/t/after-crash-network-interfaces-are-down-and-will-not-come-back-up/153672/2

TL; DR:

```shell
sudo nmcli n on
```

我真的想早日摆脱这玩意。明明有好用的内核工具，还要用虚拟网卡，不值得。

但是手写 `iptables` 规则真的太难了，我试了几次自定义的规则链，无一成功。



## 安装并配置 `cgproxy` 

若您也使用 Arch Linux, 那麽可以在 [AUR](https://aur.archlinux.org/packages/cgproxy/) 上找到 `cgproxy`, 不过 `paru` 似乎没法编译软件包，所以得亲自动手。

```shell
git clone https://aur.archlinux.org/packages/cgproxy.git
cd cgproxy
less PKGBUILD
makepkg -si
```

装好以后就可以开始配置。

```shell
sudo vim /etc/cgproxy/config.json
```

一般的话，它应该长这样：

```json
{
    "comment":"For usage, see https://github.com/springzfx/cgproxy",

    "port": 12345,
    "program_noproxy": ["v2ray","qv2ray"],
    "program_proxy": [],
    "cgroup_noproxy": [],
    "cgroup_proxy": ["/"],
    "enable_gateway": false,
    "enable_dns": true,
    "enable_udp": true,
    "enable_tcp": true,
    "enable_ipv4": true,
    "enable_ipv6": true,
    "table": 10007,
    "fwmark": 39283
}
```

如果没有被绕过，所有的连接都会被转发到指定的端口。

这只是个预设的文件，按需修改。

想要更详细的解释，请看 [这](https://github.com/springzfx/cgproxy) 。

**对于 *`"programs"`* 这个字段，请注意：** 

如果您想要设置**不**位于 `/usr/bin` 中的程式，请务必填写该程式的**完整路径**，否则 `cgproxy` 将无法处理。

记得在 `"program_noproxy"` 里面 添加 `trojan-go` 的路径。



## 安装 `v2ray-core`

有好几种方法可以把 `v2ray` 装到你的系统中。

1. [archlinuxcn](https://repo.archlinuxcn.org/x86_64/) 已经包含了 `v2ray`, 直接安装即可。

   可执行文件是 `/usr/bin/v2ray`, 资源目录在 `/usr/share/v2ray`.

2. `v2ray-core` 的开发者预先写好了一个 [shell 脚本](https://github.com/v2fly/fhs-install-v2ray) 来帮助用家安装。

   可执行文件是 `/usr/local/bin/v2ray`, 资源目录在 `/usr/local/share/v2ray`.

3. 也可以手动安装。 `v2ray-core` 的开发者亦提供了编译好的文件。

   你可以下载下来，按需解压，路径你自己定。

**当心，手动安装意味着手动升级。方法一可随系统更新，方法二则内建了自启的更新。**

如 `cgproxy` 的作者所言 [^-1], v2ray TPROXY 模式需要以 root 身份运行，或者特批权限。

可以添加一个 [进程守护](https://github.com/springzfx/cgproxy/blob/master/v2ray_config/v2ray.service)，或者

```shell
sudo setcap "cap_net_admin,cap_net_bind_service=ep" $(which v2ray)
```

如果您的 `v2ray` 不在 `$PATH` 中，请把 `$(which v2ray)` 换成你的 `v2ray` 可执行文件的路径。

**请务必注意：在每次滚包后，这个权限似乎都会掉，需要重新添加。**（开机自启就是个好主意）



## 安装 `trojan-go`

我直接把预编译的二进制文件拿下来了。当然也有其他方法。

```shell
wget https://github.com/p4gefau1t/trojan-go/releases/download/v0.10.6/trojan-go-linux-amd64.zip
unzip trojan-go-linux-amd64.zip # -o /usr/local/bin/trojan-go
```

然后修改配置。 `"run_type": "client"`, 差不多也就够了。反正我就自用而已。

我把这个放在另一个终端单独跑，此处使用 `gnome-terminal`.

然后再写两个脚本，一个负责启动 `trojan-go`, 另一个用来把这个脚本灌进 `gnome-terminal`.

```shell
#!/bin/bash
# 1.sh
sudo $TROJAN_GO_PATH --config $CONFIG_PATH
```

```shell
#!/bin/bash
# 2.sh
gnome-terminal --maximize -- '$PATH_TO_1.sh'
```

我加了一个参数 `--maximize` 来避免窗口错位。不然，在自启时，终端窗口的标题栏会躲进桌面顶部的状态栏里面。

将 `2.sh` 加入登录脚本以确保开机自启。

然后直接开跑，它会工作的。



## 安装并配置 `Qv2ray`

`Qv2ray` 可以在 [archlinuxcn][0] 和 AUR[^1] [^2] 找到。

安装 `qv2ray-dev-git` 是个不坏的主意。

如果你有 `archlinuxcn` 源，就可以轻易地安装预先编译好的包。

```shell
sudo pacman -S qv2ray-dev-git
```

如果您安装了 AUR 助手，比如 `paru` 之类的，那也很简单。

```shell
paru -S qv2ray-dev-git
```

你手动编译也成。

```shell
git clone https://aur.archlinux.org/packages/qv2ray-dev-git.git
# Or git clone https://aur.archlinux.org/packages/qv2ray.git
cd qv2ray-dev-git
# cd qv2ray
less PKGBUILD
makepkg -si
```

然后应该就可以打开 `qv2ray` 了。

图形界面长这样。

![](../../asset/d7401/interface-0.png)

在这， `qv2ray` 只是作爲一个可视化的分流界面来使用，作 `iptables` 与 `cgproxy` 的补充。

打开 “首选项”，选定“内核设定”，修改 “V2Ray 核心设定” 让 `qv2ray` 可以正常调用 `v2ray` 核心。

![](../../asset/d7401/preferences-0.png)

啓用 `socks5` 和 `http` 代理。

<!--可以降低 `cgproxy` 和 `iptables` 的透明代理负担-->

记得设置好 `dokodemo-door` 的端口，要注意保持一致。

![](../../asset/d7401/preferences-1.png)

重新调节代理设置以确保全局代理正常运行。

嗅探可以不开，直接转发比较省力。

DNS 拦截可以使 `fakedns` 工作，但似乎慢一点。

![](../../asset/d7401/dns-0.png)

然后添加新的连接。我单纯把请求转发给 `trojan-go`, 用了一个 `socks5` 出站。

![](../../asset/d7401/new-0.png)![](../../asset/d7401/new-1.png)

若要用 `fakedns`, 可以右击连接，选择 “编辑为 JSON”。 若你不熟悉 `Fake DNS`，可以康康 [这篇文章](https://tachyondevel.medium.com/%E6%BC%AB%E8%B0%88%E5%90%84%E7%A7%8D%E9%BB%91%E7%A7%91%E6%8A%80%E5%BC%8F-dns-%E6%8A%80%E6%9C%AF%E5%9C%A8%E4%BB%A3%E7%90%86%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-62c50e58cbd0)，是 `Kitsunebi` 作者写的，还有 [这篇](https://blog.skk.moe/post/what-happend-to-dns-in-proxy/)，是 Sukka 写的。

![](../../asset/d7401/fakedns.png)

```json
    "dns": {
        "servers": [
            "fakedns"
        ]
    },
    "fakedns": {
        "ipPool": "198.18.0.0/15",
        "poolSize": 65535
    },
```

双击或右击该连接，`qv2ray` 应该能跑起来了。

再次检查 `"program_noproxy"` 的路径，应该都能工作了。



## Drop ICMP 

最后记得加一行指令干掉 ICMP，开机启动，防止裸连泄露。

```shell
#!/bin/bash

sudo iptables -A OUTPUT -p icmp -o $OUT_NC -j REJECT
```

把 `$OUT_NC` 换成你网卡的名字。



## 参考

[^-1]: https://github.com/springzfx/cgproxy#notes

[0]: https://repo.archlinuxcn.org/x86_64/	"qv2ray"

[^1]: https://aur.archlinux.org/packages/qv2ray-dev-git/
[^2]: https://aur.archlinux.org/packages/qv2ray/

